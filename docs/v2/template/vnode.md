# 虚拟DOM&diff
## 什么是虚拟DOM
* 虚拟DOM就是把DOM数据化，利用javascript对象描述DOM结构
* 一个虚拟DOM的结构是这样的
```js
{
    tag:'div',
        props:{ id:'app', class:'container' },
    children: [
        { tag: 'h1', children:'沐华' }
    ]
}

```
它包含了下面几个属性：
1. tag：必选。就是标签。也可以是组件，或者函数
2. props：非必选。就是这个标签上的属性和方法
3. children：非必选。就是这个标签的内容或者子节点

## AST和虚拟DOM有什么区别
**Vue中的AST和虚拟DOM有什么区别啊？看着都长的一个样?**

template先转成AST，然后AST再转成render函数，render函数再转成VNode。
> 点击跳转：[模板如何转换为元素](/v2/template/flow)

## 为什么要使用虚拟DOM？
* 原生DOM拥有非常多的属性和方法，就算创建一个空div也要不少的代价
* 虽然后面出现了模板引擎这种东西，可以让我们一次性去更新多个dom。但是当引擎内某个数据发生变化时，他要操作dom去重新渲染整个引擎。
* 虚拟DOM不过是一个javascript对象，生成它比直接生成DOM的成本要低得多

## 什么是diff算法
diff算法就是用于比较新旧两个虚拟dom之间差异，找出最小化的更新视图的一种算法。

### vue中的diff
在vue中，diff算法就叫做`patch`,参考的snabbdom
> 点击跳转：[patch函数是什么](/v2/template/patch.html#patch函数是什么)

在页面首次渲染的时候会调用一次 patch 并创建新的 vnode，不会进行更深层次的比较
然后是在组件中数据发生变化时，会触发 setter 然后通过 Notify 通知 Watcher，对应的 Watcher 会通知更新并执行更新函数，它会执行 render 函数获取新的虚拟 DOM，然后执行 patch 对比上次渲染结果的老的虚拟 DOM，并计算出最小的变化，然后再去根据这个最小的变化去更新真实的 DOM，也就是视图。

## diff算法的优化
按照最直接的思维，比较新旧两个虚拟DOM，那么就应该分别递归遍历两个节点，进行比较，可是这样的效率很低。

为了优化diff算法，实现最小量更新，做了一些策略上的优化：

1. 只有同一个虚拟节点，才会进行精细化比较

这里的同一个虚拟节点，判断依据是：tag和key都相同。如果被判断不是同一个节点，不仅这两个虚拟节点不比较，而且里面的子节点也不比较了。
直接暴力拆除旧的，插入新的。

2. 只比较同一层级，不跨级比较。

即使是同一片虚拟节点，但是跨层了，不会进行diff比较，依旧暴力删除旧的、然后插入新的。    

::: warning
像上面两种情况，万一里面还有很多相同的、可复用的节点，岂不是很浪费？

答：实际开发中很少遇到这两种情况，损失几乎可以忽略。   
:::
